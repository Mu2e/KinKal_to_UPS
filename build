#! /bin/bash
#
# Master script to build and install KinKal.
#

usage() {
echo "

Script to build, test, install and cleanup the KinKal UPS product.

usage: build <options>

Option Value      Description
    -b            build code (optional, default = no )
    -C            clean up working directories ( optional, default=no)
    -c            VALUE cmake version and qualifiers ( optional, default="v3_18_2", used only for the build step)
    -d upsRoot    path to the root of the target UPS directory (required if -i selected)
    -i            install as a UPS product ( optional, default=no)
    -j value      maximum number of build threads (optional, default =1)
    -n            do a new clone; if absent expect on to be present (optional, default=no)
    -r value      root version and qualifiers (optional, if not specfied it will use UPS active)
    -t            run the tests (optional, default=no, only works if -b is also specified )
    -v gitVersion name of the git tag (required)
    -V            make this script verbose (optional, default = no )
    -x extraQuals additional qualifiers to include in the name of the UPS product ( optional, default = "" )
    -h            print this help

For additional details see: https://github.com/kutschke/KinKal_to_UPS
"
}

checkConfiguration(){
  if [[ -z "$doBuild" && -z "$doInstall" && -z "$doClean" ]]; then
    echo "ERROR - no actions requested"
    return 1
  fi

  if [[ -n "$doInstall" && -z "$gitVersion" ]]; then
    echo "ERROR - you must supply a version when requesting an install."
    return 2
  fi

  if [[ -n "$doBuild" && -z "$cmakever" ]]; then
    echo "ERROR - you must supply a cmake version when requesting a build."
    return 3
  fi

  return 0
}

# Gymnastics with root qualifiers to predefine several variants that will be needed.
processROOTQualifiers(){

  # If a root version was not specified by command line argument, then see
  # if there is a root already setup in the environment and use that.
  if [[ -n "${rootCmdLineOption}" ]]; then
     rootQuals=`echo ${rootCmdLineOption} | awk '{print $2}' | sed 's/-q//' | sed 's/+//g'`
     root_version_local=`echo ${rootCmdLineOption} | awk '{print $1}' `
  elif [[ -n ${SETUP_ROOT} ]]; then
     rootQuals=`echo ${SETUP_ROOT} | awk '{print $NF}'`
     root_version_local=${ROOT_VERSION}
     rootCmdLineOption="$ROOT_VERSION -q$rootQuals"
  else
     # If we are only cleaning then we do not need root
     if [[ -n "$doBuild" && -n "$doInstall" ]]; then
       echo "Error - you must either supply the -r option or have an already setup version of ROOT in your shell."
       return 1
     fi
  fi

  # Define both the debug and prof versions of the qualifer strings.
  echo ${rootQuals} | grep -q prof
  if [[ "$?" == "0" ]]; then
     profRootQuals=${rootQuals}
     debugRootQuals=`echo ${rootQuals} | sed 's/prof/debug/' | sed 's/:/ /g' | tr " " "\n" | sort | tr "\n" " " | xargs | tr " " ":"`
     profColonQuals=${qualifiers_colons}
     debugColonQuals=`echo ${profColonQuals} | sed 's/prof/debug/' | sed 's/:/ /g' | tr " " "\n" | sort | tr "\n" " " | xargs | tr " " ":"`
  else
    echo ${rootQuals} | grep -q debug
    if [[ "$?" == "0" ]]; then
      debugRootQuals=${rootQuals}
      profRootQuals=`echo ${rootQuals} | sed 's/debug/prof/' | sed 's/:/ /g' | tr " " "\n" | sort | tr "\n" " " | xargs | tr " " ":"`
      debugColonQuals=${qualifiers_colons}
      profColonQuals=`echo ${debugColonQuals} | sed 's/debug/prof/' | sed 's/:/ /g' | tr " " "\n" | sort | tr "\n" " " | xargs | tr " " ":"`
    else
      # Expect one of prof or debug; if we are only cleaning then we do not need root
      if [[ -n "$doBuild" && -n "$doInstall" ]]; then
        echo "Error - Expected root to have either a prof or a debug qualifier"
        return 1
      fi
    fi
  fi

  # Qualifier string with plus signs, needed to setup root
  plusProfRootQuals=`echo "+"${profRootQuals} | sed 's/:/:+/g'`
  plusDebugRootQuals=`echo "+"${debugRootQuals} | sed 's/:/:+/g'`

  return 0
}

# Fetch the code to be built.  If no version is specified, use the head of the default branch.
getCode() {
  if [[ -n "${doClone}" ]]; then
    echo "Begin clone and checkout for KinKal tag "$gitVersion
    git clone git@github.com:KFTrack/KinKal.git
    if [[ "$?" != "0" ]]; then
     return 1
    fi
    cd KinKal
    if [[ -n "$gitVersion" ]]; then
      git checkout -b ${gitVersion}_build_branch ${gitVersion}
      if [[ "$?" != "0" ]]; then
         return 2
      fi
    fi
    cd ..
  else
    echo "Using existing clone of KinKal: "
  fi # End test on doClone defined

  # Report the commit to be  built
  if [[ -d KinKal ]]; then
    cd KinKal
    git log -n 1 --decorate=full | cat  # Need the pipe cat or it may pipe to less
    git status
    cd ..
  else
    echo "Error - The directory KinKal does not exist. "
    return 3
  fi

  return 0
}

clean(){
  echo "Begin clean up. "
  for dir in KinKal build_prof build_debug; do
    if [[ -d ${dir} ]]; then
      echo "Removing " ${dir}
      /bin/rm -rf ${dir}
    fi
  done
}


install() {

  echo "Begin install. "

  if [[ -d build_prof ]]; then
    ${thisDir}/install ${gitVersion} ${upsRoot} ${root_version_local} ${profRootQuals}
  fi

  if [[ -d build_debug ]]; then
    ${thisDir}/install ${gitVersion} ${upsRoot} ${root_version_local} ${debugRootQuals}
  fi

  return 0
}

# ********** main **********

productName=KinKal

# The directory that contains this script (and others that it will run).
thisDir=`dirname $(readlink -f $0)`

# Default values for command line argument options
cmakever="v3_18_2"
doClone=""
doBuild=""
doClean=""
doInstall=""
doTest=""
gitVersion=""
nBuildThreads="1"
upsRoot="${PWD}/artexternals"
rootCmdLineOption=""
verbose=""
extraQuals=""

while getopts abCc:d:ij:nr:tv:Vxh OPT; do
    case $OPT in
        b)
            doBuild=true
            ;;
        C)  doClean=true
            ;;
        c)  cmakever=$OPTARG
            ;;
        d)
            upsRoot=$OPTARG
            ;;
        i)
            doInstall=true
            ;;
        j)  nBuildThreads=$OPTARG
            ;;
        n)  doClone=true
            ;;
        r)  rootCmdLineOption=$OPTARG
            ;;
        t)  doTest="true"
            ;;
        v)
            gitVersion=$OPTARG
            ;;
        V)
            verbose="true"
            ;;
        x)
            extraQuals=$OPTARG
            ;;
        h)
            usage
            exit 0
            ;;
        *)
            echo "Error - unknown option, exiting"
	    usage
            exit 1
            ;;
     esac
done

# Control building one or both build types.
doprof="true"
dodebug="true"

processROOTQualifiers
if [[ "$?" != "0" ]]; then
  exit 1
fi

if [[ -n "$verbose" ]]; then
  echo "productName:       " ${productName}
  echo "thisDir:           " ${thisDir}
  echo "doClone:           " ${doClone}
  echo "doBuild:           " ${doBuild}
  echo "doClean:           " ${doClean}
  echo "cmakever:          " ${cmakever}
  echo "doInstall:         " ${doInstall}
  echo "upsRoot:           " ${upsRoot}
  echo "rootCmdLineOption: " ${rootCmdLineOption}
  echo "doTest:            " ${doTest}
  echo "gitVersion:        " ${gitVersion}
  echo "nBuildThreads:     " ${nBuildThreads}
fi

if ! checkConfiguration ; then
  usage
  exit 2
fi

if [ -n "$doBuild" ]; then
  if ! getCode ; then
    exit 3
  fi
  ${thisDir}/build_one_version ${cmakever} "${root_version_local} -q${plusProfRootQuals}" ${nBuildThreads} ${doTest}
  if [[ "$?" != "0" ]]; then
     exit 4
  fi
  ${thisDir}/build_one_version ${cmakever} "${root_version_local} -q${plusDebugRootQuals}" ${nBuildThreads} ${doTest}
  if [[ "$?" != "0" ]]; then
     exit 5
  fi
fi

if [ -n "$doInstall" ]; then
  if ! install ; then
    exit 6
  fi
fi

if [ -n "$doClean" ]; then
  if ! clean ; then
    exit 7
  fi
fi

echo "KinKal_to_UPS/build completed with status 0"
exit 0
